---
title: "01_effectsize_calc_aggregate"
author: "Yixian Huang"
output:
  html_document:
    toc: yes
    number_sections: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set up
## check working directory
```{r, echo=FALSE}
rm(list=ls())
rprojroot::find_rstudio_root_file()
```

## Load packages  
```{r, warning=FALSE, message = FALSE}
library(metafor)
library(psych)
library(plyr)
library(dplyr)
library(readxl)     
library(BSDA)
options(scipen = 999)
options(digits = 6) 
```

## Read Data 
```{r}
IGRMdata <- read.csv("../data/processed/df_es_combined.csv")
str(IGRMdata)
```

# Preparation
## Types of ES calculation
What variable do we need? 
1. IGrm (2 groups): m_pre_int,  sd_pre_int,   n_pre_int
                    m_post_int,  sd_post_int, n_post_int
                    m_pre_ctl, sd_pre_ctl,  n_pre_ctl
                    m_post_ctl, sd_post_ctl, n_post_ctl
                    
2. RM (1 group):    m_diff, sd_diff, r_pre_post, n_diff

3. IG (2 groups):   m_post_int,  sd_post_int, n_post_int
                    m_post_ctl, sd_post_ctl, n_post_ctl
                    
## ES naming schame (for current study)
                    
| Type                    | Effect Size Column | Variance Column  |
|-------------------------|--------------------|------------------|
| Pretest only            | `g_pre`            | `v_pre`          |
| Posttest only           | `g_post`           | `v_post`         |
| delayed only            | `g_delayed`          | `v_delayed`        |
| Pre → Post (r = 0.5)    | `g_p2post_r05`     | `v_p2post_r05`   |
| Pre → Post (r = 0.7)    | `g_p2post_r07`     | `v_p2post_r07`   |
| Pre → Post (r = 0.9)    | `g_p2post_r09`     | `v_p2post_r09`   |
| Pre → delayed (r = 0.5) | `g_p2delayed_r05`    | `v_p2delayed_r05`  |
| Pre → delayed (r = 0.7) | `g_p2delayed_r07`    | `v_p2delayed_r07`  |
| Pre → delayed (r = 0.9) | `g_p2delayed_r09`    | `v_p2delayed_r09`  | 
                    
# ES Calculation
## IG data (pre, post, delayed)
```{r}
IGRMdata <- escalc(
  measure = "SMD",
  m1i = m_pre_int, sd1i = sd_pre_int, n1i = n_pre_int,
  m2i = m_pre_ctl, sd2i = sd_pre_ctl, n2i = n_pre_ctl,
  data = IGRMdata, replace = TRUE,
  var.names = c("g_pre", "v_pre"), vtype = "LS2"
)

IGRMdata <- escalc(
  measure = "SMD",
  m1i = m_post_int, sd1i = sd_post_int, n1i = n_post_int,
  m2i = m_post_ctl, sd2i = sd_post_ctl, n2i = n_post_ctl,
  data = IGRMdata, replace = TRUE,
  var.names = c("g_post", "v_post"), vtype = "LS2"
)

IGRMdata <- escalc(
  measure = "SMD",
  m1i = m_delayed_int, sd1i = sd_delayed_int, n1i = n_delayed_int,
  m2i = m_delayed_ctl, sd2i = sd_delayed_ctl, n2i = n_delayed_ctl,
  data = IGRMdata, replace = TRUE,
  var.names = c("g_delayed", "v_delayed"), vtype = "LS2"
)
```

## IGRM data (pre-post, pre-delayed)
### Pooled Pre-test SD
```{r}
IGRMdata <- IGRMdata %>%
  mutate(
    s2_pre_pooled = ((sd_pre_int^2) * (n_pre_int - 1) + (sd_pre_ctl^2) * (n_pre_ctl - 1)) / 
                     (n_pre_int + n_pre_ctl - 2),
    s_pre_pooled = sqrt(s2_pre_pooled)
  )
```

### Compute IGRM ESs with r = .5, .7, .9 (pre to post & pre to delayed)
#### Filter Valid Data 
```{r}
complete_pre2post <- IGRMdata %>%
  filter(complete.cases(m_pre_int, m_post_int, n_post_int,
                        m_pre_ctl, m_post_ctl, n_post_ctl, 
                        s_pre_pooled))

complete_pre2delayed <- IGRMdata %>%
  filter(complete.cases(m_pre_int, m_delayed_int, n_delayed_int,
                        m_pre_ctl, m_delayed_ctl, n_delayed_ctl, 
                        s_pre_pooled))
```

#### Pre 2 Post
```{r}
complete_pre2post <- complete_pre2post %>%
  mutate(
    r05 = 0.5,
    r06 = 0.6,
    r07 = 0.7,
  )

for (r_label in c("05", "06", "07")) {

  ri_vector <- complete_pre2post[[paste0("r", r_label)]]

  # Step 1: Treatment group
  complete_pre2post <- escalc(
    measure = "SMCR",
    m1i = m_post_int, m2i = m_pre_int,
    sd1i = s2_pre_pooled, ni = n_post_int, ri = ri_vector,
    data = complete_pre2post,
    var.names = c(paste0("g_int_p2post_", r_label), paste0("v_int_p2post_", r_label)),
    vtype = "LS2"
  )

  # Step 2: Control group
  complete_pre2post <- escalc(
    measure = "SMCR",
    m1i = m_post_ctl, m2i = m_pre_ctl,
    sd1i = s2_pre_pooled, ni = n_post_ctl, ri = ri_vector,
    data = complete_pre2post,
    var.names = c(paste0("g_ctl_p2post_", r_label), paste0("v_ctl_p2post_", r_label)),
    vtype = "LS2"
  )

  # Step 3: Subtract & combine variance
  g_col <- paste0("g_p2post_", r_label)
  v_col <- paste0("v_p2post_", r_label)
  g_int_col <- paste0("g_int_p2post_", r_label)
  g_ctl_col <- paste0("g_ctl_p2post_", r_label)
  v_int_col <- paste0("v_int_p2post_", r_label)
  v_ctl_col <- paste0("v_ctl_p2post_", r_label)

  complete_pre2post[[g_col]] <- complete_pre2post[[g_int_col]] - complete_pre2post[[g_ctl_col]]
  complete_pre2post[[v_col]] <- complete_pre2post[[v_int_col]] + complete_pre2post[[v_ctl_col]]
}
```

#### Pre 2 delayed
```{r}
complete_pre2delayed <- complete_pre2delayed %>%
  mutate(
    r05 = 0.5,
    r06 = 0.6,
    r07 = 0.7,
   )

for (r_label in c("05", "06", "07")) {
  
  ri_vector <- complete_pre2delayed[[paste0("r", r_label)]]
  
  # Step 1: Treatment group
  complete_pre2delayed <- escalc(
    measure = "SMCR",
    m1i = m_delayed_int, m2i = m_pre_int,
    sd1i = s2_pre_pooled, ni = n_delayed_int, ri = ri_vector,
    data = complete_pre2delayed,
    var.names = c(paste0("g_int_p2delayed_", r_label), paste0("v_int_p2delayed_", r_label)),
    vtype = "LS2"
  )
  
  # Step 2: Control group
  complete_pre2delayed <- escalc(
    measure = "SMCR",
    m1i = m_delayed_ctl, m2i = m_pre_ctl,
    sd1i = s2_pre_pooled, ni = n_delayed_ctl, ri = ri_vector,
    data = complete_pre2delayed,
    var.names = c(paste0("g_ctl_p2delayed_", r_label), paste0("v_ctl_p2delayed_", r_label)),
    vtype = "LS2"
  )
  
  # Step 3: Subtract & combine variance
  g_col <- paste0("g_p2delayed_", r_label)
  v_col <- paste0("v_p2delayed_", r_label)
  g_int_col <- paste0("g_int_p2delayed_", r_label)
  g_ctl_col <- paste0("g_ctl_p2delayed_", r_label)
  v_int_col <- paste0("v_int_p2delayed_", r_label)
  v_ctl_col <- paste0("v_ctl_p2delayed_", r_label)
  
  complete_pre2delayed[[g_col]] <- complete_pre2delayed[[g_int_col]] - complete_pre2delayed[[g_ctl_col]]
  complete_pre2delayed[[v_col]] <- complete_pre2delayed[[v_int_col]] + complete_pre2delayed[[v_ctl_col]]
}
```

## Combine data
```{r}
ES_combined <- IGRMdata %>% 
  select(id_sample, id_es_int, starts_with("g_"),starts_with("v_"))

ES_combined <- ES_combined %>%
  left_join(
    complete_pre2post %>% select(id_es_int, starts_with("g_p2post_"), starts_with("v_p2post_")),
    by = "id_es_int"
  ) %>%
  left_join(
    complete_pre2delayed %>% select(id_es_int, starts_with("g_p2delayed_"), starts_with("v_p2delayed_")),
    by = "id_es_int"
  )
```
## Fill missing IGRM post/delayed ES values with corresponding g_post / g_delayed
Missing values in g_p2post_rXX and g_p2delayed_rXX were imputed using g_post and g_delayed respectively, under the assumption that single-group posttest estimates can approximate the missing repeated-measure contrast when no pretest data were available.

```{r}
ES_filled <- ES_combined %>%
  mutate(
    across(starts_with("g_p2post_"), ~ ifelse(is.na(.), g_post, .)),
    across(starts_with("v_p2post_"), ~ ifelse(is.na(.), v_post, .)),
    across(starts_with("g_p2delayed_"), ~ ifelse(is.na(.), g_delayed, .)),
    across(starts_with("v_p2delayed_"), ~ ifelse(is.na(.), v_delayed, .))
  )
```

# Check Outliers 


# ES Aggregation
## FE
```{r}

```

## REML
```{r}

```

# --------------------OLD -----------------

## Type 1: IGrm (descriptive data) 
1. IGrm (2 groups): m_pre_int,  sd_pre_int,   n_pre_int
                    m_post_int,  sd_post_int, n_post_int
                    m_pre_ctl, sd_pre_ctl,  n_pre_ctl
                    m_post_ctl, sd_post_ctl, n_post_ctl


## Outlier - residual 
```{r}
res <- rma(yi = final.delta, vi = final.v, data = IGRMdata_post, method = "REML")

inf <- influence(res)
IGRMdata_post$cook.d <- inf$inf$cook.d
IGRMdata_post$rstudent <- inf$inf$rstudent

filter(IGRMdata_post, cook.d > 4/nrow(IGRMdata_post) )
filter(IGRMdata_post, abs(rstudent) > 2.5)

hist(IGRMdata_post$rstudent, main = "Histogram of Studentized Residuals", xlab = "Studentized Residuals")


```

## > write.csv < Raw ES

```{r}
# IGRMdata_post<- filter(IGRMdata_post, cook.d <= 4/nrow(IGRMdata_post) )

write.csv(IGRMdata_post, file = "[OUTPUT] ES Calc.csv", row.names = FALSE)
head(IGRMdata_post)
```

# Aggregated ES
## Store details in a list
```{r, EVAL = FALSE}
ES_summary_list <- list()

for (id in unique(IGRMdata_post$ConditionID)){
  subset_data <- subset(IGRMdata_post, ConditionID == id)
  
  RE_pooled <- rma(yi = final.delta,
                  vi = final.v,
                  test = "knha", #"knha"
                  data=subset_data,
                  method = "REML") # REML
  
  ES_summary_list[[id]] <- RE_pooled
}

# Check report 
# ES_summary_list[["152-VGm"]]
ES_summary_list[["152-VG_R"]]
```

## Store aggregated ES in a table
```{r}
ES_summary_table <- data.frame(
  ConditionID = character(),
  tau2 = numeric(),
  I2 = numeric(),
  H2 = numeric(),
  QE = numeric(),
  QEp = numeric(),
  delta.agg = numeric(),
  se = numeric(),
  df = numeric(),
  tval = numeric(),
  ci.lb = numeric(),
  ci.ub = numeric(),
  stringsAsFactors = FALSE
)

for (id in unique(IGRMdata_post$ConditionID)) {
  subset_data <- subset(IGRMdata_post, ConditionID == id)
  
  RE_pooled <- rma(yi = final.delta,
                   vi = final.v,
                   test = "knha", # knha
                   data = subset_data,
                   method = "REML") # REML or FE
  
  extracted_data <- data.frame(
    ConditionID = id,  # 当前循环的 ConditionID
    tau2 = ifelse(!is.null(RE_pooled$tau2), RE_pooled$tau2, NA),
    I2 = ifelse(!is.null(RE_pooled$I2), RE_pooled$I2, NA),
    H2 = ifelse(!is.null(RE_pooled$H2), RE_pooled$H2, NA),
    QE = ifelse(!is.null(RE_pooled$QE), RE_pooled$QE, NA),
    QEp = ifelse(!is.null(RE_pooled$QEp), RE_pooled$QEp, NA),
    delta.agg = RE_pooled$b,
    se = RE_pooled$se,
    df = RE_pooled$df, 
    pval = RE_pooled$pval,
    ci.lb = RE_pooled$ci.lb,
    ci.ub = RE_pooled$ci.ub,
    stringsAsFactors = FALSE
  )
  
  # 将提取的数据追加到 summary_table
  ES_summary_table <- rbind(ES_summary_table, extracted_data)
}
```

## > write.csv < Aggre ES
```{r}
write.csv(ES_summary_table, file = "[OUTPUT] ES Aggregate.csv", row.names = FALSE)
```

# Data Combine for BNMA requirment (By condition ID)
## prepare codes data
Note. The difference between ConditionID and Comparison is that - ConditionID include both int and ctl groups, while ConditionID exclude ctl groups.
```{r}
# Prepare BNMA code data
codes_data <- read_excel("/Users/yh_mac24/Desktop/BNMA data processing/[1] Raw Data/[RAW] MRI Codebook and Raw Data.xlsx", sheet = "clean_mod") %>%
       filter(EX_Identifier != "EX") %>%  
       distinct(ConditionID, .keep_all = TRUE) %>% 
       #one row per condition
       select(SampleID, ConditionID, ConditionType, treatment)
```


```{r}
matched_data <- merge(codes_data, ES_summary_table , 
                      by = "ConditionID", all.x = TRUE, all.y = FALSE) 
# DELETE invalid groups after removing outliers
# Logic. ALL int has a ES value. Only ctl groups are allowed to have no ES value. 
filter(matched_data, (ConditionType != "ctl" & is.na(delta.agg)))
matched_data <- filter(matched_data, 
                       !(ConditionType != "ctl" & is.na(delta.agg)))
```

## impute min_se for ctl group
```{r}
matched_data <- matched_data %>%
  group_by(SampleID) %>%
  mutate(
    min_se = min(se, na.rm = TRUE),  # 计算每组的最小 SE 值
    se_inpute = ifelse(is.na(se), min_se - 0.00001, se)  # 填充 NA 值为最小值减去 0.001
  ) # %>%
#  select(-min_se)  # 删除临时列
```

## procude BNMA processing data
```{r}
BNMA_code_data <- matched_data %>%
   select(SampleID, delta.agg, se_inpute, treatment, tau2, ConditionID) %>%
   rename(
          study = SampleID,      
          diff = delta.agg,      
          std.err = se_inpute,
          treatment = treatment)

```

## final Check
```{r}
result <- BNMA_code_data %>%
          group_by(study) %>%
          summarise(
            has_one_na = sum(is.na(diff)) == 1,           # 检查是否有且只有一个 NA
            has_value = sum(!is.na(diff)) > 0,           # 检查是否至少有一个数值
            unique_treatments_count = n_distinct(treatment), # 统计 treatment 的唯一值数量
            has_unique_treatments = unique_treatments_count >= 2 # 是否有至少两种不重复的 treatment
          ) %>%
          mutate(valid = has_one_na & has_value & has_unique_treatments) # 三个条件都满足

( invalid_studies <-filter(result, !valid) )

```

## > write.csv < BNMA ES
```{r}
write.csv(BNMA_code_data, "[OUTPUT] BNMA_code_and_ES.csv", row.names = FALSE)
```


